[
  {
    "title": "Reverse Engineering and Analyzing Malware: MAKOP",
    "pubDate": "2024-08-02 14:46:37",
    "link": "https://medium.com/@ivancmoliveira/reverse-engineering-and-analyzing-malware-makop-9d91b6c3dafd?source=rss-1e8854d9f0c9------2",
    "guid": "https://medium.com/p/9d91b6c3dafd",
    "author": "Ivan Oliveira",
    "thumbnail": "",
    "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*MfplgnZ0vRoRmnZ6.png\"></figure><h3>History</h3>\n<p>MAKOP Ransomware first appeared in 2020 as an offshoot of the PHOBOS variant and has infected many computers since then. Files encrypted by MAKOP usually have the the extension “.makop” or “.mkp”. MAKOP uses RSA and AES encryption.</p>\n<p>Like almost all ransomware groups, MAKOP uses different techniques to enter companies’ networks and inject the payload. The most common is through RDP vulnerabilities. The least frequent spread is by sending spam via e-mail.</p>\n<h3>Basic Summary</h3>\n<p>During the detonation of the MAKOP Ransomware in a controlled environment, it is possible to notice that the encrypted files are renamed to:</p>\n<p>“filename.[target_id].[datastore@cyberfear.com].mkp”</p>\n<p>It’s very important to understand that there are different variants of MAKOP Ransomware operating today and being executed by different groups of cybercriminals.</p>\n<h3>Technical Summary</h3>\n<p>After being executed, the MAKOP Ransomware checks the execution permissions, if there are any arguments passed, creates the program’s heap, allocates memory in it. It then begins decrypting the payload and starts the encryption functions on the target system.</p>\n<p>During the encryption phase, the ransomware scans the computer for shared folders, and if it finds them and has permissions, it encrypts the files in them.</p>\n<p>Below is an example of a Windows 7 machine infected by MAKOP Ransomware.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2-wgQvCIr32XzVf8\"></figure><p>We may notice that one of the indicators of compromise (IOCs) is the change in the device’s wallpaper, as well as the change in file names. In the following chapters we will explore the main functions of ransomware in detail, including its encryption of system files.</p>\n<h3>Ransomware composition</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/645/1*U1TIUDcX-fhDFJZDWFSouQ.png\"></figure><p><strong>Makop.exe</strong><br>This is the final payload of the ransomware, usually residing inside another file with packing techniques used to obfuscate the malicious payload and bypass security tools present on the targets.</p>\n<p>The obfuscation methods used by MAKOP can vary, in some cases we can find SmartAssembly via .NET or UPX.</p>\n<h3>Static Analysis</h3>\n<h4>1.1 — Attack Tactics and Techniques (MITRE ATT&amp;CK Framework &amp; Behavior)</h4>\n<p>The analysis reveals a program with a comprehensive set of capabilities including inter process communication, cryptography and defense evasion. It uses various techniques for persistence, lateral movement and impact, including the creation of reverse shells and manipulation of Windows registries.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/888/0*lPFlw6F0zv99qgPB\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/893/0*sLZqcUKpQZy3EXYq\"></figure><h4>1.2 — Capabilities</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/905/0*psAVa50JPnZY2NMi\"></figure><h4>1.3 — Windows API</h4>\n<p>The malware can perform a series of malicious actions using Windows APIs, such as elevating privileges by manipulating access tokens (DuplicateTokenEx, OpenProcessToken) and injecting code into legitimate processes to operate stealthily (CreateProcessW, OpenProcess).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/598/0*049WEil9fD6iTkuj\"></figure><p>It can also ensure persistence on the system by creating new malicious processes and manipulating system files (WriteFile, SetFileAttributesW), as well as encrypting user files to extort money, using encryption functions (CryptEncrypt, CryptGenRandom).</p>\n<p>For defense evasion, malware can obfuscate data and communication (CryptAcquireContextW) and use mutexes to avoid multiple instances (CreateMutex).</p>\n<p>Additionally, malware can exploit network functions to enumerate and access network resources, facilitating lateral propagation (WNetEnumResourceW).</p>\n<p>It can also read and exfiltrate sensitive data to external servers (ReadFile, WriteFile), move and hide critical files (MoveFileW, SetFileAttributesW), and terminate security processes to avoid detection (TerminateProcess).</p>\n<p>These actions allow the malware to cause significant damage to the system, hide its presence and ensure its continued execution, making it difficult to detect and remove by security measures.</p>\n<h4>1.4 —VirusTotal/Tria.Ge/</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/903/0*7LuRJiMy3-mhBuHZ\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*MKuhGQmJKeZ0LHEO\"></figure><p>During the analysis we can see that the file was found under a different name but with the same SHA-256 hash. Indicated as malicious by 66 security tools and categorized as part of the PHOBOS/MAKOP family.</p>\n<h4>1.5 — Cutter</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/0*xX5cchYVhnMj20dc\"></figure><p>In the image above we can see the malware’s execution flow, starting with the main function. Initially, the program checks that it is running with administrator privileges using the ‘isRunningAsAdmin’ function and then processes the command line arguments.</p>\n<p>Depending on the results, it can follow different execution paths. The code allocates memory using ‘HeapAlloc’ and initializes application settings with ‘InitAppSettings’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/810/0*dIG7OHhehgrWMW5l\"></figure><p>If the initialization of the environment and settings is successful, the flow continues to ‘payloadEncrypFunc’, otherwise it clears the allocated memory with ‘CleanupMemory’ and ends the process using ‘ExitProcess’.</p>\n<p>Note that some functions and variables have been named based on their actions and results after code analysis by reverse engineering.</p>\n<h4>1.6 — Ghidra</h4>\n<p><strong>1.6.1 — Function payloadEncrypFunc</strong></p>\n<p>The ‘payloadEncryptFunc’ function handles the initialization and execution of encryption payloads, using various system operations and critical sections. It starts by making memory copies and retrieving locality information using ‘GetLocaleInfoW’.</p>\n<p>Depending on the results of these operations, the function can initialize decryption systems and critical sections, ensuring that proper synchronization is maintained when entering and exiting critical sections. If certain conditions are met, the function proceeds to initialize encryption and execute the necessary commands.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/719/0*BPtO6-R1WTDwtMik\"></figure><p>The function contains several checks and calls to other functions, such as ‘initDecryptSys’,’ InitializeCriticalSectionManager’ and ‘CleanupAndRestartThread’, indicating a complex interaction between different system states and cryptography routines.</p>\n<p>It also involves mutex checking and creation, ensuring that operations are synchronized and preventing race conditions or conflicts in a multi-threaded environment. Overall, the function’s main role is to manage the secure and synchronized execution of cryptography-related tasks.</p>\n<p><strong>1.6.2 — Function initDecryptSys</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/562/0*wrdFrDLCMVR1drQu\"></figure><p>The ‘initDecryptSy’s function is responsible for performing decryption operations and managing heap allocation and release. It starts by decrypting a data entry using ‘DecryptDataEntry’ and storing the result in ‘pbVar3’.</p>\n<p>It then checks that the decryption result is not null and that a certain global value is not set. If the conditions are met, the ‘ProcessSubstrings()’ function is called.</p>\n<p><strong>1.6.3 — Function DecryptDataEntry</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/0*PEMjjEXScuyaL49Z\"></figure><p>The ‘DecryptDataEntry’ function is responsible for decrypting a data entry specified by a search key (searchKey) and returns a pointer to the decrypted data, as well as the size of the decrypted data via an output parameter (decryptedSize). Below is a detailed explanation of its operation:</p>\n<p><strong>1.6.3.1 — Initial Check and Preparation</strong><br>The function starts by checking whether a pointer to a data array exists at the position specified by ‘in_EAX + 8’. If this pointer is not null, it extracts the first value (uVar1) from the array to determine the number of entries.</p>\n<p><strong>1.6.3.2 — Search Loop</strong><br>A loop is started to go through all the entries in the array, looking for the search key (searchKey). For each entry, 8 bytes of data are copied to local variables.</p>\n<p><strong>1.6.3.3 — Checking the Key</strong><br>If the key (local_c) matches the search key (searchKey), the function continues to process this entry. It checks that ‘local_8’ is greater than ‘local_a’ to calculate the size (n) of the data to be decrypted.</p>\n<p><strong>1.6.3.4 — Memory allocation</strong><br>If the size (n) is valid, the function allocates memory to store the decrypted data using ‘HeapAlloc’. If the allocation fails, the function returns null.</p>\n<p><strong>1.6.3.5 — Copying and Decrypting Data</strong><br>The data is copied to the allocated memory. The function enters a critical section to ensure synchronization during the decryption operation.<br>The ‘firstAESKey’ function is called to obtain the encryption key.<br>‘CryptDecrypt’ is used to decrypt the data.</p>\n<p><strong>1.6.3.6 — Finalization and Release of Resources</strong><br>If decryption is successful, the function updates the size of the decrypted data. If an encryption key is in use, it is destroyed with CryptDestroyKey. The function exits the critical section and returns the pointer to the decrypted data.</p>\n<p><strong>1.6.3.7 — Error and cleanup</strong><br>If any step fails, the function cleans up the allocated resources and returns null.</p>\n<h4><strong>1.6.4 — Function firstAESKey</strong></h4>\n<p>The firstAESKey function is responsible for configuring the AES encryption key and importing this key to be used in subsequent cryptographic operations. The function performs various operations related to acquiring cryptographic context and importing the AES key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/465/0*9uU4IaOyQrQDJxnM\"></figure><p>The function checks whether the encryption provider (hProv) is already acquired. If not, it tries to acquire a cryptographic context using ‘CryptAcquireContextW’. If this operation fails, the function returns ‘0’ indicating failure.</p>\n<p>A buffer (pbData) is prepared with specific values. This buffer will be used to import the key. The AES key is copied to ‘crypKey’ and ‘CryptImportKey’ is called to import this key into the encryption provider (hProv).</p>\n<p>If the import fails, the function calls ‘GetLastError()’ to get the error code and ‘returnFunc()’ to perform any cleanup or additional operations required, returning 0 if it fails.</p>\n<p>Looking at the documentation for the ‘CryptImportKey’ function, we can see that one of the expected values is ‘pbData’, which is nothing more than a BYTE array containing a PUBLICKEYSTRUC BLOB header followed by the encryption key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/874/0*om4SFePwX0_eDrKy\"></figure><p>A PUBLICKEYSTRUC must contain its type, version, reserved buffer and the key algorithm.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/278/0*QkCvsjYKNiASS-58\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/291/0*wwXCXy7DMHByO9az\"></figure><p>In the malware code, we can see that the values of the respective fields are: 02,08 and 6610.</p>\n<p>‘bType’ with a value of 0x8 means a key blob in plain text.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/514/0*g6j2K53PWk2KnOTO\"></figure><p>‘bVersion’ with a value of 2 is the minimum standard required.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/873/0*X5s3glhP3Z5O_QaZ\"></figure><p>‘aiKeyAlg’ 0x6610 means an AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/849/0*X1CPpEbh7VvKMg1h\"></figure><p>With this, we can confirm that the array at the beginning of the function represents BYTES for an AES-256 key that will be used for decryption.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/0*7MHRdB59S_WxY7-m\"></figure><p>If we add all the values together, we get the following AES-256 key:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/612/1*NnpeyYUkOlcd9DN1jSBICA.png\"></figure><h4>1.6.5 — Function <strong>initEncrypt</strong>\n</h4>\n<p>Returning to the payloadEncryptFunc function and calling initEncrypt, we can see that it is responsible for initializing the encryption process, taking into account the operating system version and whether the user has administrator privileges.</p>\n<p>The function performs a series of checks and calls other functions to configure the encryption environment and perform encryption as required.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/0*Obasf2DxS4dFtGwh\"></figure><p>The function starts by initializing registry settings with ‘InitRegistrySettings’ and managing critical sections with ‘InitCriticSectManager’. It retrieves the operating system version using ‘GetVersion’ if the result is not already set (GetVersionResult).</p>\n<p>It also checks whether the Windows version is lower than 6 (Windows Vista) and sets ‘windowsVersion’ to ‘0’ if this is the case. If the Windows version is ‘6’ or higher, it sets ‘windowsVersion’ to ‘1’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/692/0*__UHtaADtRiyVuoG\"></figure><p>If the user does not have administrator privileges (isAdminUser is 0), the function creates threads for standard encryption and waits for them to finish. If the user has administrator privileges, the function enters the critical section, checks the process exit code, and if necessary, manipulates the critical section and checks whether the system is Windows XP or 2000.</p>\n<p>It then performs system encryption by calling ‘EncryptSystem’, call ‘DynamicLibraryLoader’ again to ensure that all the necessary libraries are loaded. If there is data associated with to ‘DAT_0041b250’, it processes this data to set the wallpaper, then calls ‘ProcessDecryptedData’ to finish processing the decrypted data.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/623/0*Z18hlalFejime5vz\"></figure><h4>1.6.6 — Function <strong>encryptSystem</strong>\n</h4>\n<p>The ‘encryptSystem’ function is responsible for starting the system encryption process, performing various preliminary operations and calling other specific functions to configure and perform file encryption. It creates a new AES key with ‘genNewAESKey’ and encrypts it with ‘encryptAESkeyy’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/386/0*Qk0QztSuak_2bnae\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/309/0*Z3UClw6Cj3tR0ZLs\"></figure><p>The function calls ‘encryptFilesFunc’ to encrypt files. If the ‘in_EAX’ pointer is null, it is replaced by ‘DAT_00419a30’. It then calls ‘encryptFilesFunc’ and ‘callEncryptRoutine’ for various drive variables (DAT_0041b258, DAT_0041b284, DAT_0041b278).</p>\n<p>Unlike the first AES-256 key, the new one is generated randomly at each execution of the ransomware by the ‘CryptGenRandom()’ function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/332/0*DSCACIUayUxup8-v\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/605/0*qM4HB4S-oKcTOtaj\"></figure><p>After being generated, the new AES-256 key is encrypted using a public RSA key. The final key generated by the process is then used to encrypt the system files. We’ll delve deeper into this flow during the dynamic analysis.</p>\n<h3>Dynamic Analysis</h3>\n<p>During the dynamic analysis phase, we can confirm theories raised about the malware’s functionalities during the static analysis.Tools and sandboxes were used to automate the process, as well as manual analysis in a controlled environment.</p>\n<h4>2.1 — Signatures</h4>\n<p>The malware’s activities include deleting shadow copies and backup catalogs, using tools such as ‘wbadmin.exe’ to prevent system recovery, and mass renaming of files, characterizing data encryption.</p>\n<p>In addition, the malware modifies the desktop wallpaper via the registry and uses the shadow copies service via COM API to manage backups and snapshots, reinforcing its destruction and persistence capabilities.</p>\n<p>Other threats include spyware and stealers, which aim to collect data from browsers, such as saved credentials. The malware’s suspicious behavior includes process enumeration, use of ‘AdjustPrivilegeToken’ and ‘WriteProcessMemory’, as well as running ping.exe to check connectivity.</p>\n<p>The malware also abuses legitimate hosting services for command and control (C2) and uses Task Scheduler via COM API to ensure continuous and automated execution of its malicious operations.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/593/0*rlrZW7RfaJNaoZPr\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/684/0*7YhDVo6VLFV8MBNw\"></figure><h4>2.2 — Process Tree</h4>\n<p>We can see that the malware begins its execution from the folder where it is located. Once executed, it performs a series of operations, including deleting shadow copies using ‘vssadmin.exe’ and ‘wmic.exe’, as well as deleting the backup catalog with ‘wbadmin.exe’, actions that aim to prevent the system from recovering.</p>\n<p>In addition to these operations, the malware uses the ‘cmd.exe’ process to execute additional commands, such as running ‘ping.exe’ to check connectivity and using ‘fsutil.exe’ to manipulate files.</p>\n<p>Other components include ‘vssvc.ex’e, ‘wbengine.exe’, and ‘vdsldr.exe’, which are used to control and manipulate system backup and recovery services.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/928/0*N7iwQ-PF857rA6Oa\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/0*Vpazt08m5fnV-0Jo\"></figure><h4>2.3 — Registry Keys</h4>\n<p>We can see that some processes are associated with registry values that reveal configuration changes in the user state. In addition, the ‘SgrmBroker.exe’ process is identified with a significant registry value under the Windows Management Instrumentation (WMI) security key, indicating possible security manipulation and malware persistence.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*nvX5HwiI4JFOTuzB\"></figure><h4>2.4 —Host indicators</h4>\n<p>During the dynamic analysis it is possible to notice some direct changes to the host, such as a new wallpaper and ransom notes.</p>\n<p><strong>2.4.1 — Wallpaper change</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*qvbwZpeIc3Nvvd5J\"></figure><p><strong>2.4.2 — Ransom note<br></strong>During its execution, the malware saves a file called ‘+README-WARNING+.txt’ on the host. It is present on the desktop and in all directories where files have been encrypted.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/712/0*6SNJgfWmKy0StbLw\"></figure><p><strong>2.4.3 — Encrypted files<br></strong>By analyzing the files encrypted by the malware, we can see that the structure of the names has been changed to the following:</p>\n<p>filename.extension.[target_id].[datastore@cyberfear.com].mkp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/403/0*9PX_PltLCJ-yzyTq\"></figure><p>We can confirm that the third parameter ‘[target_id]’ really refers to the proposed name by analyzing the execution of the malware on another host. We can see that the value changes on different hosts.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/310/0*uAFhcIiQWQZEy9Bi\"></figure><h4>2.5 — Network indicators</h4>\n<p>We noticed several DNS and HTTP requests, suggesting external communication activities and possible data exfiltration. Among the requests observed, the DNS query for the iplogger.com domain stands out, followed by a GET request for the URL ‘xttps://iplogger.com/1FcD4’, which may indicate a tracking mechanism or collection of IP information.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/462/0*yXT3rsvTiBlMgVUs\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rU83I0ktuj8sRGJ9\"></figure><p>The traffic shows multiple backup list requests via the BROWSER protocol, indicating an attempt to map network resources and identify available devices on the local network.</p>\n<p>In addition, there are several DNS queries, including requests to resolve PTR addresses and domains such as ‘x1.c.lencr.org’, ‘c.pki.goog/r/gsr1.crl’ and ‘c.pki.goog/r/r4.crl’ that may be associated with certificate verification activities or an attempt to avoid detection.</p>\n<p>The HTTP requests observed include attempts to download certification update files from URLs such as ‘/msdownload/update/v3/static/trustedr/en/disallowedcertstl.cab’, suggesting that the malware is manipulating lists of trusted and revoked certificates to maintain secure communication and avoid detection by security mechanisms.</p>\n<p>These activities, combined with NBNS requests to resolve workgroup names, indicate a coordinated effort to map, compromise and maintain persistence on the target network.</p>\n<h4>2.6 — Cryptography Routine</h4>\n<p>During the analysis of the malware code using Ghidra software, it was possible to identify the encryption flow and the addresses responsible for this operation.</p>\n<p>0x00401537 = genNewAESKey / CryptGenRandom()<br>0x004015a6 = genNewAESKey / CryptGenRandom()<br>0x00402794 = encryptWRSA / CryptImportKey()<br>0x004027CF = encryptWRSA / CryptEncrypt()<br>0x00402734 = genRandomInitVector / CryptGenRandom()<br>0x00402af9 = generateKeyFilesCryp / CryptImportKey()<br>0x00402b43 = encryptfile1 / firstFileEncrypt / CryptEncrypt()</p>\n<p>Using the x32dbg software we can debug the malware and check how each address and its functions work.</p>\n<h4>2.6.1–0x00401537 = genNewAESKey / CryptGenRandom()</h4>\n<p>We realize that this address is responsible for generating the first AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/378/0*Y8ZhrEJ5LU6A3u8D\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/468/0*BWPh5VCT7HYu_sjF\"></figure><h4>2.6.2–0x004015a6 = genNewAESKey / CryptGenRandom()</h4>\n<p>We realize that this address is responsible for generating the second AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/374/0*R4TaOpdlxZTs8gso\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/474/0*3cXMH2Q_o_rX1Y1q\"></figure><h4>2.6.3–<strong>0x00402794 = encryptWRSA / CryptImportKey()</strong>\n</h4>\n<p>This address is called twice and is responsible for importing the public RSA key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/602/0*PEGzgQXd8JYHRNKt\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/608/0*5NgO888eyy52T3JN\"></figure><h4>2.6.4–<strong>0x004027CF = encryptWRSA / CryptEncrypt()</strong>\n</h4>\n<p>This address is responsible for encrypting the two AES-256 keys using the public RSA key. It also adds the BYTES DF 6D 68 7C 65 59 9A AD 0C B4 FE AC 03 to the two keys.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/525/1*_6ggki4YeDovlRaS0NX90g.png\"></figure><h4>2.6.5–0x00402734 = genRandomInitVector / CryptGenRandom()</h4>\n<p>Creates a random 16-byte Initialization Vector (IV) to be used with AES-256 keys. An IV guarantees that the same plaintext encrypted several times will result in different ciphertexts.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/626/0*k1yAWxI4U8Qso4ts\"></figure><h4>2.6.6–<strong>0x00402af9 = generateKeyFilesCryp / CryptImportKey()</strong>\n</h4>\n<p>Responsible for importing the two encrypted AES-256 keys with the public RSA key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/601/0*WSsjPIo4bvVFo01U\"></figure><h4>2.6.7–<strong>0x00402b43 = encryptfile1 / firstFileEncrypt / CryptEncrypt()</strong>\n</h4>\n<p>This address is responsible for encrypting the system’s files using the two AES-256 keys previously encrypted with the public RSA key. During the analysis, we realized that the choice of which AES-256 key to use depends on the type of file.</p>\n<p>In addition, we found that in large files, only parts of the content are encrypted, rather than the entire content, including the headers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/725/0*Lc-6ZRnseFtscZNg\"></figure><h3>Conclusion</h3>\n<p>Based on the analysis carried out, we can conclude that, with each execution, the malware generates two random AES-256 keys. Next, a public RSA key is imported and used to encrypt these two AES-256 keys.</p>\n<p>In the final stages, a random IV (initialization vector) is generated for each file to be encrypted and added to the AES-256 keys. The files are then encrypted.</p>\n<p>Decrypting the files is therefore impossible. To do this, it would be necessary to know the IV generated for each file, the public AES-256 keys and the private RSA key used to decrypt the AES-256 keys.</p>\n<p>As the process of creating the RSA key pair is carried out externally to the malware, we don’t have access to the private key. In addition, it is important to mention that after the AES-256 keys have been created and used, the ‘CryptDestroyKey()’ function is called to destroy the imported keys.</p>\n<p>We have concluded that the MAKOP ransomware represents a significant danger to vulnerable systems. This danger is not only due to its exploitation and invasion characteristics, but mainly to the way its encryption routine is executed.</p>\n<p>To date, no tools have been developed capable of decrypting files affected by the MAKOP ransomware. Due to the advanced technologies and methods used in encryption, there are currently no means of reversing the encryption of files.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9d91b6c3dafd\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*MfplgnZ0vRoRmnZ6.png\"></figure><h3>History</h3>\n<p>MAKOP Ransomware first appeared in 2020 as an offshoot of the PHOBOS variant and has infected many computers since then. Files encrypted by MAKOP usually have the the extension “.makop” or “.mkp”. MAKOP uses RSA and AES encryption.</p>\n<p>Like almost all ransomware groups, MAKOP uses different techniques to enter companies’ networks and inject the payload. The most common is through RDP vulnerabilities. The least frequent spread is by sending spam via e-mail.</p>\n<h3>Basic Summary</h3>\n<p>During the detonation of the MAKOP Ransomware in a controlled environment, it is possible to notice that the encrypted files are renamed to:</p>\n<p>“filename.[target_id].[datastore@cyberfear.com].mkp”</p>\n<p>It’s very important to understand that there are different variants of MAKOP Ransomware operating today and being executed by different groups of cybercriminals.</p>\n<h3>Technical Summary</h3>\n<p>After being executed, the MAKOP Ransomware checks the execution permissions, if there are any arguments passed, creates the program’s heap, allocates memory in it. It then begins decrypting the payload and starts the encryption functions on the target system.</p>\n<p>During the encryption phase, the ransomware scans the computer for shared folders, and if it finds them and has permissions, it encrypts the files in them.</p>\n<p>Below is an example of a Windows 7 machine infected by MAKOP Ransomware.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*2-wgQvCIr32XzVf8\"></figure><p>We may notice that one of the indicators of compromise (IOCs) is the change in the device’s wallpaper, as well as the change in file names. In the following chapters we will explore the main functions of ransomware in detail, including its encryption of system files.</p>\n<h3>Ransomware composition</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/645/1*U1TIUDcX-fhDFJZDWFSouQ.png\"></figure><p><strong>Makop.exe</strong><br>This is the final payload of the ransomware, usually residing inside another file with packing techniques used to obfuscate the malicious payload and bypass security tools present on the targets.</p>\n<p>The obfuscation methods used by MAKOP can vary, in some cases we can find SmartAssembly via .NET or UPX.</p>\n<h3>Static Analysis</h3>\n<h4>1.1 — Attack Tactics and Techniques (MITRE ATT&amp;CK Framework &amp; Behavior)</h4>\n<p>The analysis reveals a program with a comprehensive set of capabilities including inter process communication, cryptography and defense evasion. It uses various techniques for persistence, lateral movement and impact, including the creation of reverse shells and manipulation of Windows registries.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/888/0*lPFlw6F0zv99qgPB\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/893/0*sLZqcUKpQZy3EXYq\"></figure><h4>1.2 — Capabilities</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/905/0*psAVa50JPnZY2NMi\"></figure><h4>1.3 — Windows API</h4>\n<p>The malware can perform a series of malicious actions using Windows APIs, such as elevating privileges by manipulating access tokens (DuplicateTokenEx, OpenProcessToken) and injecting code into legitimate processes to operate stealthily (CreateProcessW, OpenProcess).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/598/0*049WEil9fD6iTkuj\"></figure><p>It can also ensure persistence on the system by creating new malicious processes and manipulating system files (WriteFile, SetFileAttributesW), as well as encrypting user files to extort money, using encryption functions (CryptEncrypt, CryptGenRandom).</p>\n<p>For defense evasion, malware can obfuscate data and communication (CryptAcquireContextW) and use mutexes to avoid multiple instances (CreateMutex).</p>\n<p>Additionally, malware can exploit network functions to enumerate and access network resources, facilitating lateral propagation (WNetEnumResourceW).</p>\n<p>It can also read and exfiltrate sensitive data to external servers (ReadFile, WriteFile), move and hide critical files (MoveFileW, SetFileAttributesW), and terminate security processes to avoid detection (TerminateProcess).</p>\n<p>These actions allow the malware to cause significant damage to the system, hide its presence and ensure its continued execution, making it difficult to detect and remove by security measures.</p>\n<h4>1.4 —VirusTotal/Tria.Ge/</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/903/0*7LuRJiMy3-mhBuHZ\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*MKuhGQmJKeZ0LHEO\"></figure><p>During the analysis we can see that the file was found under a different name but with the same SHA-256 hash. Indicated as malicious by 66 security tools and categorized as part of the PHOBOS/MAKOP family.</p>\n<h4>1.5 — Cutter</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/875/0*xX5cchYVhnMj20dc\"></figure><p>In the image above we can see the malware’s execution flow, starting with the main function. Initially, the program checks that it is running with administrator privileges using the ‘isRunningAsAdmin’ function and then processes the command line arguments.</p>\n<p>Depending on the results, it can follow different execution paths. The code allocates memory using ‘HeapAlloc’ and initializes application settings with ‘InitAppSettings’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/810/0*dIG7OHhehgrWMW5l\"></figure><p>If the initialization of the environment and settings is successful, the flow continues to ‘payloadEncrypFunc’, otherwise it clears the allocated memory with ‘CleanupMemory’ and ends the process using ‘ExitProcess’.</p>\n<p>Note that some functions and variables have been named based on their actions and results after code analysis by reverse engineering.</p>\n<h4>1.6 — Ghidra</h4>\n<p><strong>1.6.1 — Function payloadEncrypFunc</strong></p>\n<p>The ‘payloadEncryptFunc’ function handles the initialization and execution of encryption payloads, using various system operations and critical sections. It starts by making memory copies and retrieving locality information using ‘GetLocaleInfoW’.</p>\n<p>Depending on the results of these operations, the function can initialize decryption systems and critical sections, ensuring that proper synchronization is maintained when entering and exiting critical sections. If certain conditions are met, the function proceeds to initialize encryption and execute the necessary commands.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/719/0*BPtO6-R1WTDwtMik\"></figure><p>The function contains several checks and calls to other functions, such as ‘initDecryptSys’,’ InitializeCriticalSectionManager’ and ‘CleanupAndRestartThread’, indicating a complex interaction between different system states and cryptography routines.</p>\n<p>It also involves mutex checking and creation, ensuring that operations are synchronized and preventing race conditions or conflicts in a multi-threaded environment. Overall, the function’s main role is to manage the secure and synchronized execution of cryptography-related tasks.</p>\n<p><strong>1.6.2 — Function initDecryptSys</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/562/0*wrdFrDLCMVR1drQu\"></figure><p>The ‘initDecryptSy’s function is responsible for performing decryption operations and managing heap allocation and release. It starts by decrypting a data entry using ‘DecryptDataEntry’ and storing the result in ‘pbVar3’.</p>\n<p>It then checks that the decryption result is not null and that a certain global value is not set. If the conditions are met, the ‘ProcessSubstrings()’ function is called.</p>\n<p><strong>1.6.3 — Function DecryptDataEntry</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/0*PEMjjEXScuyaL49Z\"></figure><p>The ‘DecryptDataEntry’ function is responsible for decrypting a data entry specified by a search key (searchKey) and returns a pointer to the decrypted data, as well as the size of the decrypted data via an output parameter (decryptedSize). Below is a detailed explanation of its operation:</p>\n<p><strong>1.6.3.1 — Initial Check and Preparation</strong><br>The function starts by checking whether a pointer to a data array exists at the position specified by ‘in_EAX + 8’. If this pointer is not null, it extracts the first value (uVar1) from the array to determine the number of entries.</p>\n<p><strong>1.6.3.2 — Search Loop</strong><br>A loop is started to go through all the entries in the array, looking for the search key (searchKey). For each entry, 8 bytes of data are copied to local variables.</p>\n<p><strong>1.6.3.3 — Checking the Key</strong><br>If the key (local_c) matches the search key (searchKey), the function continues to process this entry. It checks that ‘local_8’ is greater than ‘local_a’ to calculate the size (n) of the data to be decrypted.</p>\n<p><strong>1.6.3.4 — Memory allocation</strong><br>If the size (n) is valid, the function allocates memory to store the decrypted data using ‘HeapAlloc’. If the allocation fails, the function returns null.</p>\n<p><strong>1.6.3.5 — Copying and Decrypting Data</strong><br>The data is copied to the allocated memory. The function enters a critical section to ensure synchronization during the decryption operation.<br>The ‘firstAESKey’ function is called to obtain the encryption key.<br>‘CryptDecrypt’ is used to decrypt the data.</p>\n<p><strong>1.6.3.6 — Finalization and Release of Resources</strong><br>If decryption is successful, the function updates the size of the decrypted data. If an encryption key is in use, it is destroyed with CryptDestroyKey. The function exits the critical section and returns the pointer to the decrypted data.</p>\n<p><strong>1.6.3.7 — Error and cleanup</strong><br>If any step fails, the function cleans up the allocated resources and returns null.</p>\n<h4><strong>1.6.4 — Function firstAESKey</strong></h4>\n<p>The firstAESKey function is responsible for configuring the AES encryption key and importing this key to be used in subsequent cryptographic operations. The function performs various operations related to acquiring cryptographic context and importing the AES key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/465/0*9uU4IaOyQrQDJxnM\"></figure><p>The function checks whether the encryption provider (hProv) is already acquired. If not, it tries to acquire a cryptographic context using ‘CryptAcquireContextW’. If this operation fails, the function returns ‘0’ indicating failure.</p>\n<p>A buffer (pbData) is prepared with specific values. This buffer will be used to import the key. The AES key is copied to ‘crypKey’ and ‘CryptImportKey’ is called to import this key into the encryption provider (hProv).</p>\n<p>If the import fails, the function calls ‘GetLastError()’ to get the error code and ‘returnFunc()’ to perform any cleanup or additional operations required, returning 0 if it fails.</p>\n<p>Looking at the documentation for the ‘CryptImportKey’ function, we can see that one of the expected values is ‘pbData’, which is nothing more than a BYTE array containing a PUBLICKEYSTRUC BLOB header followed by the encryption key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/874/0*om4SFePwX0_eDrKy\"></figure><p>A PUBLICKEYSTRUC must contain its type, version, reserved buffer and the key algorithm.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/278/0*QkCvsjYKNiASS-58\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/291/0*wwXCXy7DMHByO9az\"></figure><p>In the malware code, we can see that the values of the respective fields are: 02,08 and 6610.</p>\n<p>‘bType’ with a value of 0x8 means a key blob in plain text.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/514/0*g6j2K53PWk2KnOTO\"></figure><p>‘bVersion’ with a value of 2 is the minimum standard required.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/873/0*X5s3glhP3Z5O_QaZ\"></figure><p>‘aiKeyAlg’ 0x6610 means an AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/849/0*X1CPpEbh7VvKMg1h\"></figure><p>With this, we can confirm that the array at the beginning of the function represents BYTES for an AES-256 key that will be used for decryption.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/131/0*7MHRdB59S_WxY7-m\"></figure><p>If we add all the values together, we get the following AES-256 key:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/612/1*NnpeyYUkOlcd9DN1jSBICA.png\"></figure><h4>1.6.5 — Function <strong>initEncrypt</strong>\n</h4>\n<p>Returning to the payloadEncryptFunc function and calling initEncrypt, we can see that it is responsible for initializing the encryption process, taking into account the operating system version and whether the user has administrator privileges.</p>\n<p>The function performs a series of checks and calls other functions to configure the encryption environment and perform encryption as required.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/727/0*Obasf2DxS4dFtGwh\"></figure><p>The function starts by initializing registry settings with ‘InitRegistrySettings’ and managing critical sections with ‘InitCriticSectManager’. It retrieves the operating system version using ‘GetVersion’ if the result is not already set (GetVersionResult).</p>\n<p>It also checks whether the Windows version is lower than 6 (Windows Vista) and sets ‘windowsVersion’ to ‘0’ if this is the case. If the Windows version is ‘6’ or higher, it sets ‘windowsVersion’ to ‘1’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/692/0*__UHtaADtRiyVuoG\"></figure><p>If the user does not have administrator privileges (isAdminUser is 0), the function creates threads for standard encryption and waits for them to finish. If the user has administrator privileges, the function enters the critical section, checks the process exit code, and if necessary, manipulates the critical section and checks whether the system is Windows XP or 2000.</p>\n<p>It then performs system encryption by calling ‘EncryptSystem’, call ‘DynamicLibraryLoader’ again to ensure that all the necessary libraries are loaded. If there is data associated with to ‘DAT_0041b250’, it processes this data to set the wallpaper, then calls ‘ProcessDecryptedData’ to finish processing the decrypted data.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/623/0*Z18hlalFejime5vz\"></figure><h4>1.6.6 — Function <strong>encryptSystem</strong>\n</h4>\n<p>The ‘encryptSystem’ function is responsible for starting the system encryption process, performing various preliminary operations and calling other specific functions to configure and perform file encryption. It creates a new AES key with ‘genNewAESKey’ and encrypts it with ‘encryptAESkeyy’.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/386/0*Qk0QztSuak_2bnae\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/309/0*Z3UClw6Cj3tR0ZLs\"></figure><p>The function calls ‘encryptFilesFunc’ to encrypt files. If the ‘in_EAX’ pointer is null, it is replaced by ‘DAT_00419a30’. It then calls ‘encryptFilesFunc’ and ‘callEncryptRoutine’ for various drive variables (DAT_0041b258, DAT_0041b284, DAT_0041b278).</p>\n<p>Unlike the first AES-256 key, the new one is generated randomly at each execution of the ransomware by the ‘CryptGenRandom()’ function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/332/0*DSCACIUayUxup8-v\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/605/0*qM4HB4S-oKcTOtaj\"></figure><p>After being generated, the new AES-256 key is encrypted using a public RSA key. The final key generated by the process is then used to encrypt the system files. We’ll delve deeper into this flow during the dynamic analysis.</p>\n<h3>Dynamic Analysis</h3>\n<p>During the dynamic analysis phase, we can confirm theories raised about the malware’s functionalities during the static analysis.Tools and sandboxes were used to automate the process, as well as manual analysis in a controlled environment.</p>\n<h4>2.1 — Signatures</h4>\n<p>The malware’s activities include deleting shadow copies and backup catalogs, using tools such as ‘wbadmin.exe’ to prevent system recovery, and mass renaming of files, characterizing data encryption.</p>\n<p>In addition, the malware modifies the desktop wallpaper via the registry and uses the shadow copies service via COM API to manage backups and snapshots, reinforcing its destruction and persistence capabilities.</p>\n<p>Other threats include spyware and stealers, which aim to collect data from browsers, such as saved credentials. The malware’s suspicious behavior includes process enumeration, use of ‘AdjustPrivilegeToken’ and ‘WriteProcessMemory’, as well as running ping.exe to check connectivity.</p>\n<p>The malware also abuses legitimate hosting services for command and control (C2) and uses Task Scheduler via COM API to ensure continuous and automated execution of its malicious operations.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/593/0*rlrZW7RfaJNaoZPr\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/684/0*7YhDVo6VLFV8MBNw\"></figure><h4>2.2 — Process Tree</h4>\n<p>We can see that the malware begins its execution from the folder where it is located. Once executed, it performs a series of operations, including deleting shadow copies using ‘vssadmin.exe’ and ‘wmic.exe’, as well as deleting the backup catalog with ‘wbadmin.exe’, actions that aim to prevent the system from recovering.</p>\n<p>In addition to these operations, the malware uses the ‘cmd.exe’ process to execute additional commands, such as running ‘ping.exe’ to check connectivity and using ‘fsutil.exe’ to manipulate files.</p>\n<p>Other components include ‘vssvc.ex’e, ‘wbengine.exe’, and ‘vdsldr.exe’, which are used to control and manipulate system backup and recovery services.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/928/0*N7iwQ-PF857rA6Oa\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/890/0*Vpazt08m5fnV-0Jo\"></figure><h4>2.3 — Registry Keys</h4>\n<p>We can see that some processes are associated with registry values that reveal configuration changes in the user state. In addition, the ‘SgrmBroker.exe’ process is identified with a significant registry value under the Windows Management Instrumentation (WMI) security key, indicating possible security manipulation and malware persistence.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*nvX5HwiI4JFOTuzB\"></figure><h4>2.4 —Host indicators</h4>\n<p>During the dynamic analysis it is possible to notice some direct changes to the host, such as a new wallpaper and ransom notes.</p>\n<p><strong>2.4.1 — Wallpaper change</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*qvbwZpeIc3Nvvd5J\"></figure><p><strong>2.4.2 — Ransom note<br></strong>During its execution, the malware saves a file called ‘+README-WARNING+.txt’ on the host. It is present on the desktop and in all directories where files have been encrypted.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/712/0*6SNJgfWmKy0StbLw\"></figure><p><strong>2.4.3 — Encrypted files<br></strong>By analyzing the files encrypted by the malware, we can see that the structure of the names has been changed to the following:</p>\n<p>filename.extension.[target_id].[datastore@cyberfear.com].mkp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/403/0*9PX_PltLCJ-yzyTq\"></figure><p>We can confirm that the third parameter ‘[target_id]’ really refers to the proposed name by analyzing the execution of the malware on another host. We can see that the value changes on different hosts.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/310/0*uAFhcIiQWQZEy9Bi\"></figure><h4>2.5 — Network indicators</h4>\n<p>We noticed several DNS and HTTP requests, suggesting external communication activities and possible data exfiltration. Among the requests observed, the DNS query for the iplogger.com domain stands out, followed by a GET request for the URL ‘xttps://iplogger.com/1FcD4’, which may indicate a tracking mechanism or collection of IP information.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/462/0*yXT3rsvTiBlMgVUs\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*rU83I0ktuj8sRGJ9\"></figure><p>The traffic shows multiple backup list requests via the BROWSER protocol, indicating an attempt to map network resources and identify available devices on the local network.</p>\n<p>In addition, there are several DNS queries, including requests to resolve PTR addresses and domains such as ‘x1.c.lencr.org’, ‘c.pki.goog/r/gsr1.crl’ and ‘c.pki.goog/r/r4.crl’ that may be associated with certificate verification activities or an attempt to avoid detection.</p>\n<p>The HTTP requests observed include attempts to download certification update files from URLs such as ‘/msdownload/update/v3/static/trustedr/en/disallowedcertstl.cab’, suggesting that the malware is manipulating lists of trusted and revoked certificates to maintain secure communication and avoid detection by security mechanisms.</p>\n<p>These activities, combined with NBNS requests to resolve workgroup names, indicate a coordinated effort to map, compromise and maintain persistence on the target network.</p>\n<h4>2.6 — Cryptography Routine</h4>\n<p>During the analysis of the malware code using Ghidra software, it was possible to identify the encryption flow and the addresses responsible for this operation.</p>\n<p>0x00401537 = genNewAESKey / CryptGenRandom()<br>0x004015a6 = genNewAESKey / CryptGenRandom()<br>0x00402794 = encryptWRSA / CryptImportKey()<br>0x004027CF = encryptWRSA / CryptEncrypt()<br>0x00402734 = genRandomInitVector / CryptGenRandom()<br>0x00402af9 = generateKeyFilesCryp / CryptImportKey()<br>0x00402b43 = encryptfile1 / firstFileEncrypt / CryptEncrypt()</p>\n<p>Using the x32dbg software we can debug the malware and check how each address and its functions work.</p>\n<h4>2.6.1–0x00401537 = genNewAESKey / CryptGenRandom()</h4>\n<p>We realize that this address is responsible for generating the first AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/378/0*Y8ZhrEJ5LU6A3u8D\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/468/0*BWPh5VCT7HYu_sjF\"></figure><h4>2.6.2–0x004015a6 = genNewAESKey / CryptGenRandom()</h4>\n<p>We realize that this address is responsible for generating the second AES-256 key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/374/0*R4TaOpdlxZTs8gso\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/474/0*3cXMH2Q_o_rX1Y1q\"></figure><h4>2.6.3–<strong>0x00402794 = encryptWRSA / CryptImportKey()</strong>\n</h4>\n<p>This address is called twice and is responsible for importing the public RSA key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/602/0*PEGzgQXd8JYHRNKt\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/608/0*5NgO888eyy52T3JN\"></figure><h4>2.6.4–<strong>0x004027CF = encryptWRSA / CryptEncrypt()</strong>\n</h4>\n<p>This address is responsible for encrypting the two AES-256 keys using the public RSA key. It also adds the BYTES DF 6D 68 7C 65 59 9A AD 0C B4 FE AC 03 to the two keys.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/525/1*_6ggki4YeDovlRaS0NX90g.png\"></figure><h4>2.6.5–0x00402734 = genRandomInitVector / CryptGenRandom()</h4>\n<p>Creates a random 16-byte Initialization Vector (IV) to be used with AES-256 keys. An IV guarantees that the same plaintext encrypted several times will result in different ciphertexts.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/626/0*k1yAWxI4U8Qso4ts\"></figure><h4>2.6.6–<strong>0x00402af9 = generateKeyFilesCryp / CryptImportKey()</strong>\n</h4>\n<p>Responsible for importing the two encrypted AES-256 keys with the public RSA key.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/601/0*WSsjPIo4bvVFo01U\"></figure><h4>2.6.7–<strong>0x00402b43 = encryptfile1 / firstFileEncrypt / CryptEncrypt()</strong>\n</h4>\n<p>This address is responsible for encrypting the system’s files using the two AES-256 keys previously encrypted with the public RSA key. During the analysis, we realized that the choice of which AES-256 key to use depends on the type of file.</p>\n<p>In addition, we found that in large files, only parts of the content are encrypted, rather than the entire content, including the headers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/725/0*Lc-6ZRnseFtscZNg\"></figure><h3>Conclusion</h3>\n<p>Based on the analysis carried out, we can conclude that, with each execution, the malware generates two random AES-256 keys. Next, a public RSA key is imported and used to encrypt these two AES-256 keys.</p>\n<p>In the final stages, a random IV (initialization vector) is generated for each file to be encrypted and added to the AES-256 keys. The files are then encrypted.</p>\n<p>Decrypting the files is therefore impossible. To do this, it would be necessary to know the IV generated for each file, the public AES-256 keys and the private RSA key used to decrypt the AES-256 keys.</p>\n<p>As the process of creating the RSA key pair is carried out externally to the malware, we don’t have access to the private key. In addition, it is important to mention that after the AES-256 keys have been created and used, the ‘CryptDestroyKey()’ function is called to destroy the imported keys.</p>\n<p>We have concluded that the MAKOP ransomware represents a significant danger to vulnerable systems. This danger is not only due to its exploitation and invasion characteristics, but mainly to the way its encryption routine is executed.</p>\n<p>To date, no tools have been developed capable of decrypting files affected by the MAKOP ransomware. Due to the advanced technologies and methods used in encryption, there are currently no means of reversing the encryption of files.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9d91b6c3dafd\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "cybercrime",
      "cybersecurity",
      "information-security",
      "threat-intelligence",
      "malware-analysis"
    ]
  },
  {
    "title": "Reverse Engineering and Analyzing Malware: WannaCry Part 1 — General Overview",
    "pubDate": "2024-06-06 14:27:04",
    "link": "https://medium.com/@ivancmoliveira/reverse-engineering-and-analyzing-malware-wannacry-3ce8b3f6406a?source=rss-1e8854d9f0c9------2",
    "guid": "https://medium.com/p/3ce8b3f6406a",
    "author": "Ivan Oliveira",
    "thumbnail": "",
    "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lKoopnV00B7HyVoN4_qbNg.jpeg\"></figure><h3><strong>History</strong></h3>\n<p>WannaCry is a ransomware crypto-worm that targets computers running the Windows operating system by encrypting data and demanding ransom payments. The worm is also known as WannaCrypt, Wanna Decrypt0r 2.0, WanaCrypt0r 2.0, and Wanna Decryptor.</p>\n<p>It is considered a worm because it includes a transport mechanism to automatically spread itself on a network to devices vulnerable to the EternalBlue exploit.</p>\n<p>It infected over 300,000 devices worldwide during its attack that occurred in May of 2017.</p>\n<h3><strong>Basic Summary</strong></h3>\n<p>WannaCry consists of two payloads that are executed in succession, resulting in the encryption of files on the system and spreading to more devices on the same network via SMB and the internet.</p>\n<p>Once the initial file is executed, it will check for admin privileges and a connection to a specific URL. If admin privileges are granted and the URL is offline, the program will execute and fully encrypt files on the system.</p>\n<p>Basic symptoms of infection include the presence of a wallpaper with the message “Ooops, your important files are encrypted” as shown below and the presence of the following files: <em>“C:\\Windows\\tasksche.exe”</em>, <em>“C:\\Users\\%USER%\\Desktop\\@Please_Read_Me@.txt”, “C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.exe” and “C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.bmp”</em>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/728/1*QegKDF8Rg8rxQyEt8fYHpQ.jpeg\"><figcaption>Image 1</figcaption></figure><p>The file “C:\\Users%USER%\\Desktop@WanaDecryptor@.exe” is responsible for decrypting files once the ransom is paid. It also provides all the ransom information, such as the address to which bitcoin should be sent.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*YbOGs7aW_hvitD6f83sijQ.jpeg\"><figcaption>Image 2</figcaption></figure><h3>Technical Summary</h3>\n<p>The first stage payload has two main kill-switches to check when it is run:</p>\n<ol>\n<li>Verify if it is able to reach the domain “iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com”.</li>\n<li>Verify if it was executed with admin privileges.</li>\n</ol>\n<p>If the first check succeeds, the payload will exit and no actions will be taken. However, if it fails, the payload will try to create the file “tasksche.exe” under the directory “C:\\Windows”, but it will not be able to do so since admin privileges were not granted. If the file is executed with admin privileges and check 1 succeeds, no actions are taken. If check 1 fails, then the payload will run as expected.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/578/1*kbIOMWoOPHVOlpxA3R7bfg.png\"><figcaption>Image 3</figcaption></figure><h3>Ransomware Composition</h3>\n<p>WannaCry consists of the following components:</p>\n<p><em>Ransomware.wannacry.exe — MD5 Hash: DB349B97C37D22F5EA1D1841E3C89EB4</em></p>\n<p>This is the initial file for infection, the first stage payload.</p>\n<p><em>tasksche.exe — MD5 Hash:<br>E92BEBACBD9159785BC6B3284CFE022F</em></p>\n<p>The second stage payload is responsible for encrypting files on the system. Once it is dropped by the first stage payload, it will be executed and encrypt files on the system.</p>\n<p><em>@WanaDecryptor@.exe — MD5 Hash:<br>7BF2B57F2A205768755C07F238FB32CC</em></p>\n<p>The file dropped by the second stage payload is responsible for providing ransom information and decrypting files.</p>\n<h3>Static Analysis</h3>\n<p>Before running the malware on a virtual machine inside a safe environment, we can conduct a static analysis to learn more about its functions, strings, execution flow, API calls, etc. This will assist us during the dynamic analysis phase to compare and confirm results.</p>\n<h4>1. Capa</h4>\n<p>The “capa” tool detects capabilities in executable files. When run against a file, it tells what it thinks the program can do. For example, it might suggest that the file is a backdoor, is capable of installing services, or relies on HTTP to communicate. Running “capa” against “Ransomware.wannacry.exe” can help us learn more about some of its capabilities.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/895/1*DFU8fBhvSmqQuiIhFbUGtA.png\"><figcaption>Image 4</figcaption></figure><p>Based on its output, the ransomware has functions related to Defense Evasion, Discovery, Persistence, Anti-behavioral and Static Analysis, Command and Control (C2), Cryptography, Data Execution, File System, and Process handling.</p>\n<h4>2. Windows API with PEStudio</h4>\n<p>The goal of “pestudio” is to spot artifacts of executable files to ease and accelerate malware initial assessment. Reviewing the import address table for “Ransomware.wannacry.exe,” we can observe some interesting API imports.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*u3V0KchsA9Qs-ViDKBUWcA.png\"><figcaption>Image 5</figcaption></figure><p>Based on the API imports, the ransomware appears capable of:</p>\n<ul>\n<li>Creating a service using “CreateServiceA.”</li>\n<li>Connecting a service application to the Service Control Manager (SCM) with “StartServiceCtrlDispatcherA.”</li>\n<li>Sending and receiving data from a connected socket using “send” and “recv.”</li>\n<li>Retrieving information about network adapters on a computer using “GetAdaptersInfo.”</li>\n<li>Connecting to a URL using “InternetOpenUrlA.”</li>\n<li>Moving or renaming files and directories using “MoveFileExA.”</li>\n</ul>\n<p>Furthermore, it utilizes cryptographic functions:</p>\n<ul>\n<li>“CryptAcquireContext”: Acquiring a handle to a cryptographic service provider (CSP).</li>\n<li>“CryptGenKey”: Generating a cryptographic key for encryption.</li>\n<li>“CryptEncrypt”: Encrypting data using the cryptographic key.</li>\n<li>“CryptDecrypt”: Decrypting data using the cryptographic key.</li>\n<li>“CryptDestroyKey”: Destroying the cryptographic key when done.</li>\n<li>“CryptImportKey”: Importing a cryptographic key from an external source if needed.</li>\n</ul>\n<p>These imports are commonly used by ransomware authors to perform encryption of data on infected hosts.</p>\n<h4>3.1 Cutter — Strings</h4>\n<p>Cutter is a free and open-source reverse engineering platform powered by rizin. Cutter is fully integrated with the native Ghidra decompiler. Using it to search for strings inside “Ransomware.wannacry.exe,” we can observe:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_jgRV9UeSBXIi_3xuDH9HA.png\"><figcaption>Image 6</figcaption></figure><ul>\n<li>References to the URL (<em>xttp://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com</em>) inside the kill switch function mentioned earlier;</li>\n<li>SMB connections;</li>\n<li>Name of .exe files, including <em>“tasksche.exe”</em> that is dropped;</li>\n<li>Strings that looks like C strings when using the <em>“sprintf”</em> function to pass a specific string value to “%s”;</li>\n<li>String making reference to <em>“cry”</em> such as <em>“WanaCrypt0r”</em>, <em>“WNcry@2ol7”</em>, <em>“WANACRY!”</em>, <em>“gcrY1”</em> and <em>“*cRy”</em>.</li>\n</ul>\n<h4>3.1 Cutter — Main function execution flow logic</h4>\n<p>Reviewing the assembly code for the main function of the binary “Ransomware.wannacry.exe,” we can observe that functions from the WinINet API are being utilized for connection. The function “InternetOpenA” is creating a handle to be used by “InternetOpenUrlA,” which will open the URL:</p>\n<p>“xttp://<a href=\"http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com/\">www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com</a>\".</p>\n<p>Afterwards, “InternetCloseHandle” is used to close the handle created previously.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/537/1*UchkfD_XVGaxyB3iSeqaTQ.png\"><figcaption>Image 7</figcaption></figure><p>The instruction “test edi, edi” will verify if the register “edi” is zero, and the instruction “jne 0x4081bc” will jump to the address “0x4081bc” if “edi” is not zero.</p>\n<p>In other words, if the result from “InternetOpenUrlA” stored in “edi” is not 0 (resulting in a successful connection to the URL), the program will jump to address “0x4081bc”, which likely handles subsequent actions or exits the program. However, if the result is 0, indicating a failure to establish a connection, the program will proceed to address “0x004081a7,” where the payload truly starts.</p>\n<h3>Dynamic Analysis</h3>\n<p>To conduct dynamic analysis, we’ll execute the ransomware in two different scenarios: one without internet access and one with internet access. However, to prevent the ransomware from spreading to other devices on our network or to the internet, we’ll perform this analysis in a controlled and secure environment.</p>\n<p>For simulating internet access, we’ll use a Virtual Machine running the REMnux OS within VirtualBox, configured with an internal network. This setup ensures that our infected machine can only communicate with the REMnux host, preventing any potential spread to other devices.</p>\n<p>During the analysis, we’ll examine both host-based and network-based indicators to gain insights into the ransomware’s behavior and its impact on the system and network.</p>\n<h4>1.1 Host-based indicators — without REMnux</h4>\n<p>If executed without admin privileges, the ransomware attempts to create the file “tasksche.exe” under “C:\\Windows”, but since access is denied, it terminates itself. However, if executed with admin privileges, it successfully creates the file.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/946/1*9BtouZXeehwVwkESa8NCMg.png\"><figcaption>Image 8</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/936/1*Wca2G63dwvR_MTo1eH6v2Q.png\"><figcaption>Image 9</figcaption></figure><p><em>“C:\\Windows\\tasksche.exe”</em> runs as a child of the first stage payload and creates the files and directories below:<br>C:\\Windows\\@WanaDecryptor@.exe<br>C:\\ProgramData\\dveqybpwqzws072<br>C:\\ProgramData\\dveqybpwqzws072\\dveqybpwqzws072<br>C:\\ProgramData\\dveqybpwqzws072\\tasksche.exe<br>C:\\ProgramData\\dveqybpwqzws072\\taskse.exe<br>C:\\ProgramData\\dveqybpwqzws072\\taskdl.exe<br>C:\\ProgramData\\dveqybpwqzws072\\attrib.exe<br>C:\\ProgramData\\dveqybpwqzws072\\icacls.exe<br>C:\\ProgramData\\dveqybpwqzws072\\b.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\c.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\s.wnr<br>C:\\ProgramData\\dveqybpwqzws072\\r.wnr<br>C:\\ProgramData\\dveqybpwqzws072\\t.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\u.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\CRYPTSP.dll<br>C:\\ProgramData\\dveqybpwqzws072\\CRYPTBASE.dll<br>C:\\ProgramData\\dveqybpwqzws072\\crypt32.dll<br>C:\\ProgramData\\dveqybpwqzws072\\MSVCP60.dll<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.dky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.pky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.eky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.res<br>C:\\ProgramData\\dveqybpwqzws072\\@WanaDecryptor@.exe<br>C:\\ProgramData\\dveqybpwqzws072\\@Please_Read_Me@.txt<br>C:\\ProgramData\\dveqybpwqzws072\\msg<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData\\Data<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData\\Tor<br>C:\\ProgramData\\dveqybpwqzws072\\msg\\m_bulgarian.wnry<br>C:\\Users\\%USER%\\Desktop\\@Please_Read_Me@.txt<br>C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.exe<br>C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.bmp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/942/1*ZVwn6pWboj0xpkOtRyJXTw.png\"><figcaption>Image 10</figcaption></figure><p>“@WanaDecryptor@.bmp” is set as the device wallpaper, and “@WanaDecryptor@.exe” will persist on the device screen in the foreground. If the executable is closed, a secondary service will be created to ensure persistence and reopen the executable again.</p>\n<p>The files “@WanaDecryptor@.exe” and “@Please_Read_Me@.txt” are added to every folder on the system that contains files with the specified extensions. Folders that do not have files inside or files with extensions that do not match the list will not receive the malware files.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/234/1*S3lp_5l8mRH9rt0nVUwezg.png\"><figcaption>Image 11</figcaption></figure><p>Checking for services created during the ransomware execution, we observe that a service with the same name as the folder under “C:\\Windows\\ProgramData” and a service named “mssecsvc2.0” are created.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/716/1*UdUFZzhTvlSswAzP-ZIOyw.png\"><figcaption>Image 12</figcaption></figure><p>Using the Process Tree to better understand the ransomware behavior on the infected machine, we can observe that the first stage payload located on the Desktop executes “tasksche.exe” with the argument “/i”.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/781/1*X8dsnzyWiNADWSBTcgoB6A.png\"><figcaption>Image 13</figcaption></figure><p>“Ransomware.wannacry.exe” located under the Desktop is then executed by the service “mssecsvc2.0” with the argument “-m security”. Additionally, the file “tasksche.exe” under “C:\\Windows” executes “cmd” with the argument “/c C:\\ProgramData%RandomFolderName%\\tasksche.exe”.</p>\n<p>“tasksche.exe” then invokes “attrib.exe”, “icacls.exe”, and “cmd.exe” with the following arguments:</p>\n<ol>\n<li>“attrib +h .”: This command hides the current directory.</li>\n<li>“icacls ./grant Everyone/T /C /Q”: Grants full control permissions to the Everyone group for all files and directories within the current directory and its subdirectories. It continues despite errors and without showing success messages.</li>\n<li>“/c 66211717615268.bat”: Executes the batch file named “66211717615268.bat” using the command interpreter.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*Md6DH14TAV7Zaw9NTal-4g.png\"><figcaption>Image 14</figcaption></figure><p>Once that step is done, the initial “cmd” will close, and “tasksche.exe” will continue running. It will spawn “@WanaDecryptor@.exe”, “cmd.exe”, and “taskse.exe”. With “cmd.exe(7144)” as an exception, the remaining child processes will spawn “@WanaDecryptor@.exe”.</p>\n<p>As for “cmd.exe (7104)” — refer to image 15 — , it is executing the following commands in sequence:</p>\n<ul>\n<li>\n<strong>Delete all shadow copies quietly</strong>: “cmd.exe /c vssadmin delete shadows /all /quiet”</li>\n<li>\n<strong>Delete all shadow copies using WMIC:</strong> “wmic shadowcopy delete”</li>\n<li>\n<strong>Ignore all boot failures:</strong> “bcdedit /set {default} bootstatuspolicy ignoreallfailures”</li>\n<li>\n<strong>Disable Windows Recovery Environment:</strong> “bcdedit /set {default} recoveryenabled no”</li>\n<li>\n<strong>Delete the backup catalog quietly:</strong> “wbadmin delete catalog -quiet”</li>\n</ul>\n<p>In summary, this command chain aims to remove all shadow copies (used for system restore and backups), ensure that the system ignores any boot failures and attempts to boot normally, disable the recovery environment typically used to recover the system in case of boot or system failures, and remove the backup catalog containing metadata about backups. This is done in an attempt to prevent the system from recovering or performing backups once files are encrypted by the ransomware.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*AiCBvyL9OoOslkASaVTb4g.png\"><figcaption>Image 15</figcaption></figure><p>The WannaCry ransomware also persists on the infected machine by adding new registry keys as shown in the images below.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/903/1*RcY2ohoulpgH3EkHFVGvqw.png\"><figcaption>Image 16</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/825/1*ot2qOV5xUMVjQGw35UmIxg.png\"><figcaption>Image 17</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*N65iP8g4o1HIA24xOCQyig.png\"><figcaption>Image 18</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/999/1*IZYu1TvwH2chhmqp-gsHpg.png\"><figcaption>Image 19</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/999/1*zPKJlumvWPDcOOsGojQZ2w.png\"><figcaption>Image 20</figcaption></figure><p>Looking inside the hidden folder created under “C:\\ProgramData”, we can observe that the processes previously spawned as child processes are located there.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/305/1*GeXWdZeNcyjFLJDn1ZTApw.png\"><figcaption>Image 21</figcaption></figure><p>File “c.wnry” contains strings for onion addresses and a Bitcoin address.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*KNxsFt6uwPbs4cLpkICLJg.png\"><figcaption>Image 22</figcaption></figure><p>“r.wnry” is the ransom note.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*bPjsuwD6pxerKULmv-r2Bw.png\"><figcaption>Image 23</figcaption></figure><p>“s.wnry” extracts Tor files to “tasksche.exe” current directory + TaskData folder.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*jvLBNOLcEotVwZs9fakkrw.png\"><figcaption>Image 24</figcaption></figure><p>Taking a look inside the “msg” folder, we can see files that contains translations of text used within the “@WanaDecryptor@.exe” executable.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fYmBTnnZYdGQAqMawjpvIQ.png\"><figcaption>Image 25</figcaption></figure><p>Inside the “TaskData” folder, we find files related to Tor for communication with the onion network. Those were extracted by “s.wnry”. Quickly extracting the strings from the file “taskhsvc.exe,” we can observe numerous references to onion connections.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/373/1*-BxmiHxTsKdXP-ISLdQWxw.png\"><figcaption>Image 26</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtzu47elA1dYFSB2zzASCw.png\"><figcaption>Image 27</figcaption></figure><h4>1.1.1 Host-based indicators — without REMnux — Encryption Routine</h4>\n<p>The encryption routine that WannaCry uses involves the following steps:</p>\n<ol>\n<li>\n<strong>File Selection:</strong> The ransomware selects target files on the infected system for encryption. These files may include common document formats, images, videos, databases, etc.</li>\n<li>\n<strong>Encryption Algorithm:</strong> WannaCry uses strong encryption algorithms such as AES (Advanced Encryption Standard) and RSA (Rivest-Shamir-Adleman) to encrypt the selected files. AES is used for bulk file encryption, while RSA is used for encrypting the AES encryption keys.</li>\n<li>\n<strong>Key Generation:</strong> The ransomware generates a unique encryption key for each encrypted file. In some cases, it may use a symmetric encryption key for file encryption and then encrypt this key with an asymmetric encryption key pair.</li>\n<li>\n<strong>File Encryption:</strong> The selected files are encrypted using the generated encryption key. The ransomware modifies the contents of the files in such a way that they become unreadable without the corresponding decryption key.</li>\n</ol>\n<h4>1.2 Host-based indicators — with REMnux</h4>\n<p>If executed without admin privileges, the ransomware follows a similar flow as without REMnux, but it does not attempt to create “C:\\Windows\\tasksche.exe”. However, if executed with admin privileges, it exhibits the same behavior as without admin privileges; the ransomware does nothing as it can access the kill switch URL.</p>\n<h4>2. Network signatures — Wireshark and REMnux</h4>\n<p>Using Wireshark inside the REMnux host, which serves as the router for our infected machine, we can observe an attempt of communication to the kill switch URL. This confirms the connection attempt discovered in previous topics.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*21XvmLbgCjyFTS9ADw08Zw.png\"><figcaption>Image 28</figcaption></figure><h4>3. Network-based indicators — TCPView without REMnux</h4>\n<p>Analyzing the traffic from the first stage payload, we can observe multiple connections to random remote addresses on port 445. This is related to the SMB exploit EternalBlue used by WannaCry to infect other devices.</p>\n<p>As for “@WanaDecryptor@.exe,” it appears to bind to a loopback network interface, meaning it is accessible only from the same machine it is running on. It performs tunneling similar to SSH tunneling, forwarding the local port 64222 to the remote machine’s port 9050 through Tor.</p>\n<p>The file “taskhsvc.exe” exhibits a similar behavior, but it uses the local ports 6828 and 6829. The difference is that it also listens for remote connections on port 9060, also through Tor, from all addresses.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*YN0Ws2woLCVx7rAipG0STQ.png\"><figcaption>Image 29</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JEcKb-x4gQyw4GnWCqiXbw.png\"><figcaption>Image 30</figcaption></figure><h3>Indicators of compromise</h3>\n<p>As described in the previous topics there are a lot of indicators of compromise when it comes to the WannaCry Ransomware. However, we can break them down into two sub-topics: host and network-based indicators.</p>\n<h4>1. Host-based indicators</h4>\n<p><strong>Presence of files:</strong> “@WanaDecryptor@.exe”, “@Please_Read_Me@.txt”, “tasksche.exe”, “taskhsvc.exe”, etc., in various system directories.</p>\n<p><strong>Process activities:</strong> Execution of processes like “mssecsvc2.0”, “tasksche”, etc., observed in task manager or process monitoring tools.</p>\n<p><strong>File system modifications:</strong> Encrypted files with specific file extensions, such as “.encrypted”, “.wcry”, etc.</p>\n<p><strong>Wallpaper changes and Decryptor file persistance:</strong> Presence of a ransom note as the desktop wallpaper and “Wana Decrypt0r 2.0” executable spawning on the device.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uBLZmbbczV3bt3nrjPxXyg.png\"><figcaption>Image 31</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*p5VsSCEtZubwcf_inHFAfw.png\"><figcaption>Image 32</figcaption></figure><h4>2. Network-based indicators</h4>\n<p>Multiple connections to different hosts on port 445 (SMB) and to port 9050 (Tor).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*YN0Ws2woLCVx7rAipG0STQ.png\"><figcaption>Image 33</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JEcKb-x4gQyw4GnWCqiXbw.png\"><figcaption>Image 34</figcaption></figure><h3>Rules &amp; Signatures</h3>\n<p>Below is a YARA rule for detecting the presence of WannaCry ransomware inside of a executable (.exe) file.</p>\n<p><a href=\"https://github.com/Smarttfoxx/Smarttfoxx/blob/main/WannaCryYaraRule.yara\">https://github.com/Smarttfoxx/Smarttfoxx/blob/main/WannaCryYaraRule.yara</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HZYUyOl7-bZKQsoqX-7xuA.png\"><figcaption>Image 35</figcaption></figure><h3>Conclusion</h3>\n<p>The WannaCry attack highlighted showcased the destructive potential of modern cyber threats. By analyzing WannaCry’s propagation, encryption methods, and key indicators, we can gain valuable insights into its operation and prepare for future attacks.</p>\n<p>This incident shows the critical importance of timely security updates and robust cybersecurity measures. Implementing proactive strategies and effective detection methods is essential for mitigating similar threats in the future.</p>\n<p>In the next blog post, we will cover in depth the main logic behind WannaCry’s first stage payload, by reversing it in Ghidra.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3ce8b3f6406a\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lKoopnV00B7HyVoN4_qbNg.jpeg\"></figure><h3><strong>History</strong></h3>\n<p>WannaCry is a ransomware crypto-worm that targets computers running the Windows operating system by encrypting data and demanding ransom payments. The worm is also known as WannaCrypt, Wanna Decrypt0r 2.0, WanaCrypt0r 2.0, and Wanna Decryptor.</p>\n<p>It is considered a worm because it includes a transport mechanism to automatically spread itself on a network to devices vulnerable to the EternalBlue exploit.</p>\n<p>It infected over 300,000 devices worldwide during its attack that occurred in May of 2017.</p>\n<h3><strong>Basic Summary</strong></h3>\n<p>WannaCry consists of two payloads that are executed in succession, resulting in the encryption of files on the system and spreading to more devices on the same network via SMB and the internet.</p>\n<p>Once the initial file is executed, it will check for admin privileges and a connection to a specific URL. If admin privileges are granted and the URL is offline, the program will execute and fully encrypt files on the system.</p>\n<p>Basic symptoms of infection include the presence of a wallpaper with the message “Ooops, your important files are encrypted” as shown below and the presence of the following files: <em>“C:\\Windows\\tasksche.exe”</em>, <em>“C:\\Users\\%USER%\\Desktop\\@Please_Read_Me@.txt”, “C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.exe” and “C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.bmp”</em>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/728/1*QegKDF8Rg8rxQyEt8fYHpQ.jpeg\"><figcaption>Image 1</figcaption></figure><p>The file “C:\\Users%USER%\\Desktop@WanaDecryptor@.exe” is responsible for decrypting files once the ransom is paid. It also provides all the ransom information, such as the address to which bitcoin should be sent.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*YbOGs7aW_hvitD6f83sijQ.jpeg\"><figcaption>Image 2</figcaption></figure><h3>Technical Summary</h3>\n<p>The first stage payload has two main kill-switches to check when it is run:</p>\n<ol>\n<li>Verify if it is able to reach the domain “iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com”.</li>\n<li>Verify if it was executed with admin privileges.</li>\n</ol>\n<p>If the first check succeeds, the payload will exit and no actions will be taken. However, if it fails, the payload will try to create the file “tasksche.exe” under the directory “C:\\Windows”, but it will not be able to do so since admin privileges were not granted. If the file is executed with admin privileges and check 1 succeeds, no actions are taken. If check 1 fails, then the payload will run as expected.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/578/1*kbIOMWoOPHVOlpxA3R7bfg.png\"><figcaption>Image 3</figcaption></figure><h3>Ransomware Composition</h3>\n<p>WannaCry consists of the following components:</p>\n<p><em>Ransomware.wannacry.exe — MD5 Hash: DB349B97C37D22F5EA1D1841E3C89EB4</em></p>\n<p>This is the initial file for infection, the first stage payload.</p>\n<p><em>tasksche.exe — MD5 Hash:<br>E92BEBACBD9159785BC6B3284CFE022F</em></p>\n<p>The second stage payload is responsible for encrypting files on the system. Once it is dropped by the first stage payload, it will be executed and encrypt files on the system.</p>\n<p><em>@WanaDecryptor@.exe — MD5 Hash:<br>7BF2B57F2A205768755C07F238FB32CC</em></p>\n<p>The file dropped by the second stage payload is responsible for providing ransom information and decrypting files.</p>\n<h3>Static Analysis</h3>\n<p>Before running the malware on a virtual machine inside a safe environment, we can conduct a static analysis to learn more about its functions, strings, execution flow, API calls, etc. This will assist us during the dynamic analysis phase to compare and confirm results.</p>\n<h4>1. Capa</h4>\n<p>The “capa” tool detects capabilities in executable files. When run against a file, it tells what it thinks the program can do. For example, it might suggest that the file is a backdoor, is capable of installing services, or relies on HTTP to communicate. Running “capa” against “Ransomware.wannacry.exe” can help us learn more about some of its capabilities.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/895/1*DFU8fBhvSmqQuiIhFbUGtA.png\"><figcaption>Image 4</figcaption></figure><p>Based on its output, the ransomware has functions related to Defense Evasion, Discovery, Persistence, Anti-behavioral and Static Analysis, Command and Control (C2), Cryptography, Data Execution, File System, and Process handling.</p>\n<h4>2. Windows API with PEStudio</h4>\n<p>The goal of “pestudio” is to spot artifacts of executable files to ease and accelerate malware initial assessment. Reviewing the import address table for “Ransomware.wannacry.exe,” we can observe some interesting API imports.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*u3V0KchsA9Qs-ViDKBUWcA.png\"><figcaption>Image 5</figcaption></figure><p>Based on the API imports, the ransomware appears capable of:</p>\n<ul>\n<li>Creating a service using “CreateServiceA.”</li>\n<li>Connecting a service application to the Service Control Manager (SCM) with “StartServiceCtrlDispatcherA.”</li>\n<li>Sending and receiving data from a connected socket using “send” and “recv.”</li>\n<li>Retrieving information about network adapters on a computer using “GetAdaptersInfo.”</li>\n<li>Connecting to a URL using “InternetOpenUrlA.”</li>\n<li>Moving or renaming files and directories using “MoveFileExA.”</li>\n</ul>\n<p>Furthermore, it utilizes cryptographic functions:</p>\n<ul>\n<li>“CryptAcquireContext”: Acquiring a handle to a cryptographic service provider (CSP).</li>\n<li>“CryptGenKey”: Generating a cryptographic key for encryption.</li>\n<li>“CryptEncrypt”: Encrypting data using the cryptographic key.</li>\n<li>“CryptDecrypt”: Decrypting data using the cryptographic key.</li>\n<li>“CryptDestroyKey”: Destroying the cryptographic key when done.</li>\n<li>“CryptImportKey”: Importing a cryptographic key from an external source if needed.</li>\n</ul>\n<p>These imports are commonly used by ransomware authors to perform encryption of data on infected hosts.</p>\n<h4>3.1 Cutter — Strings</h4>\n<p>Cutter is a free and open-source reverse engineering platform powered by rizin. Cutter is fully integrated with the native Ghidra decompiler. Using it to search for strings inside “Ransomware.wannacry.exe,” we can observe:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_jgRV9UeSBXIi_3xuDH9HA.png\"><figcaption>Image 6</figcaption></figure><ul>\n<li>References to the URL (<em>xttp://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com</em>) inside the kill switch function mentioned earlier;</li>\n<li>SMB connections;</li>\n<li>Name of .exe files, including <em>“tasksche.exe”</em> that is dropped;</li>\n<li>Strings that looks like C strings when using the <em>“sprintf”</em> function to pass a specific string value to “%s”;</li>\n<li>String making reference to <em>“cry”</em> such as <em>“WanaCrypt0r”</em>, <em>“WNcry@2ol7”</em>, <em>“WANACRY!”</em>, <em>“gcrY1”</em> and <em>“*cRy”</em>.</li>\n</ul>\n<h4>3.1 Cutter — Main function execution flow logic</h4>\n<p>Reviewing the assembly code for the main function of the binary “Ransomware.wannacry.exe,” we can observe that functions from the WinINet API are being utilized for connection. The function “InternetOpenA” is creating a handle to be used by “InternetOpenUrlA,” which will open the URL:</p>\n<p>“xttp://<a href=\"http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com/\">www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com</a>\".</p>\n<p>Afterwards, “InternetCloseHandle” is used to close the handle created previously.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/537/1*UchkfD_XVGaxyB3iSeqaTQ.png\"><figcaption>Image 7</figcaption></figure><p>The instruction “test edi, edi” will verify if the register “edi” is zero, and the instruction “jne 0x4081bc” will jump to the address “0x4081bc” if “edi” is not zero.</p>\n<p>In other words, if the result from “InternetOpenUrlA” stored in “edi” is not 0 (resulting in a successful connection to the URL), the program will jump to address “0x4081bc”, which likely handles subsequent actions or exits the program. However, if the result is 0, indicating a failure to establish a connection, the program will proceed to address “0x004081a7,” where the payload truly starts.</p>\n<h3>Dynamic Analysis</h3>\n<p>To conduct dynamic analysis, we’ll execute the ransomware in two different scenarios: one without internet access and one with internet access. However, to prevent the ransomware from spreading to other devices on our network or to the internet, we’ll perform this analysis in a controlled and secure environment.</p>\n<p>For simulating internet access, we’ll use a Virtual Machine running the REMnux OS within VirtualBox, configured with an internal network. This setup ensures that our infected machine can only communicate with the REMnux host, preventing any potential spread to other devices.</p>\n<p>During the analysis, we’ll examine both host-based and network-based indicators to gain insights into the ransomware’s behavior and its impact on the system and network.</p>\n<h4>1.1 Host-based indicators — without REMnux</h4>\n<p>If executed without admin privileges, the ransomware attempts to create the file “tasksche.exe” under “C:\\Windows”, but since access is denied, it terminates itself. However, if executed with admin privileges, it successfully creates the file.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/946/1*9BtouZXeehwVwkESa8NCMg.png\"><figcaption>Image 8</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/936/1*Wca2G63dwvR_MTo1eH6v2Q.png\"><figcaption>Image 9</figcaption></figure><p><em>“C:\\Windows\\tasksche.exe”</em> runs as a child of the first stage payload and creates the files and directories below:<br>C:\\Windows\\@WanaDecryptor@.exe<br>C:\\ProgramData\\dveqybpwqzws072<br>C:\\ProgramData\\dveqybpwqzws072\\dveqybpwqzws072<br>C:\\ProgramData\\dveqybpwqzws072\\tasksche.exe<br>C:\\ProgramData\\dveqybpwqzws072\\taskse.exe<br>C:\\ProgramData\\dveqybpwqzws072\\taskdl.exe<br>C:\\ProgramData\\dveqybpwqzws072\\attrib.exe<br>C:\\ProgramData\\dveqybpwqzws072\\icacls.exe<br>C:\\ProgramData\\dveqybpwqzws072\\b.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\c.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\s.wnr<br>C:\\ProgramData\\dveqybpwqzws072\\r.wnr<br>C:\\ProgramData\\dveqybpwqzws072\\t.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\u.wnry<br>C:\\ProgramData\\dveqybpwqzws072\\CRYPTSP.dll<br>C:\\ProgramData\\dveqybpwqzws072\\CRYPTBASE.dll<br>C:\\ProgramData\\dveqybpwqzws072\\crypt32.dll<br>C:\\ProgramData\\dveqybpwqzws072\\MSVCP60.dll<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.dky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.pky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.eky<br>C:\\ProgramData\\dveqybpwqzws072\\00000000.res<br>C:\\ProgramData\\dveqybpwqzws072\\@WanaDecryptor@.exe<br>C:\\ProgramData\\dveqybpwqzws072\\@Please_Read_Me@.txt<br>C:\\ProgramData\\dveqybpwqzws072\\msg<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData\\Data<br>C:\\ProgramData\\dveqybpwqzws072\\TaskData\\Tor<br>C:\\ProgramData\\dveqybpwqzws072\\msg\\m_bulgarian.wnry<br>C:\\Users\\%USER%\\Desktop\\@Please_Read_Me@.txt<br>C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.exe<br>C:\\Users\\%USER%\\Desktop\\@WanaDecryptor@.bmp</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/942/1*ZVwn6pWboj0xpkOtRyJXTw.png\"><figcaption>Image 10</figcaption></figure><p>“@WanaDecryptor@.bmp” is set as the device wallpaper, and “@WanaDecryptor@.exe” will persist on the device screen in the foreground. If the executable is closed, a secondary service will be created to ensure persistence and reopen the executable again.</p>\n<p>The files “@WanaDecryptor@.exe” and “@Please_Read_Me@.txt” are added to every folder on the system that contains files with the specified extensions. Folders that do not have files inside or files with extensions that do not match the list will not receive the malware files.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/234/1*S3lp_5l8mRH9rt0nVUwezg.png\"><figcaption>Image 11</figcaption></figure><p>Checking for services created during the ransomware execution, we observe that a service with the same name as the folder under “C:\\Windows\\ProgramData” and a service named “mssecsvc2.0” are created.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/716/1*UdUFZzhTvlSswAzP-ZIOyw.png\"><figcaption>Image 12</figcaption></figure><p>Using the Process Tree to better understand the ransomware behavior on the infected machine, we can observe that the first stage payload located on the Desktop executes “tasksche.exe” with the argument “/i”.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/781/1*X8dsnzyWiNADWSBTcgoB6A.png\"><figcaption>Image 13</figcaption></figure><p>“Ransomware.wannacry.exe” located under the Desktop is then executed by the service “mssecsvc2.0” with the argument “-m security”. Additionally, the file “tasksche.exe” under “C:\\Windows” executes “cmd” with the argument “/c C:\\ProgramData%RandomFolderName%\\tasksche.exe”.</p>\n<p>“tasksche.exe” then invokes “attrib.exe”, “icacls.exe”, and “cmd.exe” with the following arguments:</p>\n<ol>\n<li>“attrib +h .”: This command hides the current directory.</li>\n<li>“icacls ./grant Everyone/T /C /Q”: Grants full control permissions to the Everyone group for all files and directories within the current directory and its subdirectories. It continues despite errors and without showing success messages.</li>\n<li>“/c 66211717615268.bat”: Executes the batch file named “66211717615268.bat” using the command interpreter.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/761/1*Md6DH14TAV7Zaw9NTal-4g.png\"><figcaption>Image 14</figcaption></figure><p>Once that step is done, the initial “cmd” will close, and “tasksche.exe” will continue running. It will spawn “@WanaDecryptor@.exe”, “cmd.exe”, and “taskse.exe”. With “cmd.exe(7144)” as an exception, the remaining child processes will spawn “@WanaDecryptor@.exe”.</p>\n<p>As for “cmd.exe (7104)” — refer to image 15 — , it is executing the following commands in sequence:</p>\n<ul>\n<li>\n<strong>Delete all shadow copies quietly</strong>: “cmd.exe /c vssadmin delete shadows /all /quiet”</li>\n<li>\n<strong>Delete all shadow copies using WMIC:</strong> “wmic shadowcopy delete”</li>\n<li>\n<strong>Ignore all boot failures:</strong> “bcdedit /set {default} bootstatuspolicy ignoreallfailures”</li>\n<li>\n<strong>Disable Windows Recovery Environment:</strong> “bcdedit /set {default} recoveryenabled no”</li>\n<li>\n<strong>Delete the backup catalog quietly:</strong> “wbadmin delete catalog -quiet”</li>\n</ul>\n<p>In summary, this command chain aims to remove all shadow copies (used for system restore and backups), ensure that the system ignores any boot failures and attempts to boot normally, disable the recovery environment typically used to recover the system in case of boot or system failures, and remove the backup catalog containing metadata about backups. This is done in an attempt to prevent the system from recovering or performing backups once files are encrypted by the ransomware.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*AiCBvyL9OoOslkASaVTb4g.png\"><figcaption>Image 15</figcaption></figure><p>The WannaCry ransomware also persists on the infected machine by adding new registry keys as shown in the images below.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/903/1*RcY2ohoulpgH3EkHFVGvqw.png\"><figcaption>Image 16</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/825/1*ot2qOV5xUMVjQGw35UmIxg.png\"><figcaption>Image 17</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/853/1*N65iP8g4o1HIA24xOCQyig.png\"><figcaption>Image 18</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/999/1*IZYu1TvwH2chhmqp-gsHpg.png\"><figcaption>Image 19</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/999/1*zPKJlumvWPDcOOsGojQZ2w.png\"><figcaption>Image 20</figcaption></figure><p>Looking inside the hidden folder created under “C:\\ProgramData”, we can observe that the processes previously spawned as child processes are located there.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/305/1*GeXWdZeNcyjFLJDn1ZTApw.png\"><figcaption>Image 21</figcaption></figure><p>File “c.wnry” contains strings for onion addresses and a Bitcoin address.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*KNxsFt6uwPbs4cLpkICLJg.png\"><figcaption>Image 22</figcaption></figure><p>“r.wnry” is the ransom note.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*bPjsuwD6pxerKULmv-r2Bw.png\"><figcaption>Image 23</figcaption></figure><p>“s.wnry” extracts Tor files to “tasksche.exe” current directory + TaskData folder.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/689/1*jvLBNOLcEotVwZs9fakkrw.png\"><figcaption>Image 24</figcaption></figure><p>Taking a look inside the “msg” folder, we can see files that contains translations of text used within the “@WanaDecryptor@.exe” executable.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fYmBTnnZYdGQAqMawjpvIQ.png\"><figcaption>Image 25</figcaption></figure><p>Inside the “TaskData” folder, we find files related to Tor for communication with the onion network. Those were extracted by “s.wnry”. Quickly extracting the strings from the file “taskhsvc.exe,” we can observe numerous references to onion connections.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/373/1*-BxmiHxTsKdXP-ISLdQWxw.png\"><figcaption>Image 26</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qtzu47elA1dYFSB2zzASCw.png\"><figcaption>Image 27</figcaption></figure><h4>1.1.1 Host-based indicators — without REMnux — Encryption Routine</h4>\n<p>The encryption routine that WannaCry uses involves the following steps:</p>\n<ol>\n<li>\n<strong>File Selection:</strong> The ransomware selects target files on the infected system for encryption. These files may include common document formats, images, videos, databases, etc.</li>\n<li>\n<strong>Encryption Algorithm:</strong> WannaCry uses strong encryption algorithms such as AES (Advanced Encryption Standard) and RSA (Rivest-Shamir-Adleman) to encrypt the selected files. AES is used for bulk file encryption, while RSA is used for encrypting the AES encryption keys.</li>\n<li>\n<strong>Key Generation:</strong> The ransomware generates a unique encryption key for each encrypted file. In some cases, it may use a symmetric encryption key for file encryption and then encrypt this key with an asymmetric encryption key pair.</li>\n<li>\n<strong>File Encryption:</strong> The selected files are encrypted using the generated encryption key. The ransomware modifies the contents of the files in such a way that they become unreadable without the corresponding decryption key.</li>\n</ol>\n<h4>1.2 Host-based indicators — with REMnux</h4>\n<p>If executed without admin privileges, the ransomware follows a similar flow as without REMnux, but it does not attempt to create “C:\\Windows\\tasksche.exe”. However, if executed with admin privileges, it exhibits the same behavior as without admin privileges; the ransomware does nothing as it can access the kill switch URL.</p>\n<h4>2. Network signatures — Wireshark and REMnux</h4>\n<p>Using Wireshark inside the REMnux host, which serves as the router for our infected machine, we can observe an attempt of communication to the kill switch URL. This confirms the connection attempt discovered in previous topics.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*21XvmLbgCjyFTS9ADw08Zw.png\"><figcaption>Image 28</figcaption></figure><h4>3. Network-based indicators — TCPView without REMnux</h4>\n<p>Analyzing the traffic from the first stage payload, we can observe multiple connections to random remote addresses on port 445. This is related to the SMB exploit EternalBlue used by WannaCry to infect other devices.</p>\n<p>As for “@WanaDecryptor@.exe,” it appears to bind to a loopback network interface, meaning it is accessible only from the same machine it is running on. It performs tunneling similar to SSH tunneling, forwarding the local port 64222 to the remote machine’s port 9050 through Tor.</p>\n<p>The file “taskhsvc.exe” exhibits a similar behavior, but it uses the local ports 6828 and 6829. The difference is that it also listens for remote connections on port 9060, also through Tor, from all addresses.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*YN0Ws2woLCVx7rAipG0STQ.png\"><figcaption>Image 29</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JEcKb-x4gQyw4GnWCqiXbw.png\"><figcaption>Image 30</figcaption></figure><h3>Indicators of compromise</h3>\n<p>As described in the previous topics there are a lot of indicators of compromise when it comes to the WannaCry Ransomware. However, we can break them down into two sub-topics: host and network-based indicators.</p>\n<h4>1. Host-based indicators</h4>\n<p><strong>Presence of files:</strong> “@WanaDecryptor@.exe”, “@Please_Read_Me@.txt”, “tasksche.exe”, “taskhsvc.exe”, etc., in various system directories.</p>\n<p><strong>Process activities:</strong> Execution of processes like “mssecsvc2.0”, “tasksche”, etc., observed in task manager or process monitoring tools.</p>\n<p><strong>File system modifications:</strong> Encrypted files with specific file extensions, such as “.encrypted”, “.wcry”, etc.</p>\n<p><strong>Wallpaper changes and Decryptor file persistance:</strong> Presence of a ransom note as the desktop wallpaper and “Wana Decrypt0r 2.0” executable spawning on the device.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uBLZmbbczV3bt3nrjPxXyg.png\"><figcaption>Image 31</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/852/1*p5VsSCEtZubwcf_inHFAfw.png\"><figcaption>Image 32</figcaption></figure><h4>2. Network-based indicators</h4>\n<p>Multiple connections to different hosts on port 445 (SMB) and to port 9050 (Tor).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/945/1*YN0Ws2woLCVx7rAipG0STQ.png\"><figcaption>Image 33</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JEcKb-x4gQyw4GnWCqiXbw.png\"><figcaption>Image 34</figcaption></figure><h3>Rules &amp; Signatures</h3>\n<p>Below is a YARA rule for detecting the presence of WannaCry ransomware inside of a executable (.exe) file.</p>\n<p><a href=\"https://github.com/Smarttfoxx/Smarttfoxx/blob/main/WannaCryYaraRule.yara\">https://github.com/Smarttfoxx/Smarttfoxx/blob/main/WannaCryYaraRule.yara</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HZYUyOl7-bZKQsoqX-7xuA.png\"><figcaption>Image 35</figcaption></figure><h3>Conclusion</h3>\n<p>The WannaCry attack highlighted showcased the destructive potential of modern cyber threats. By analyzing WannaCry’s propagation, encryption methods, and key indicators, we can gain valuable insights into its operation and prepare for future attacks.</p>\n<p>This incident shows the critical importance of timely security updates and robust cybersecurity measures. Implementing proactive strategies and effective detection methods is essential for mitigating similar threats in the future.</p>\n<p>In the next blog post, we will cover in depth the main logic behind WannaCry’s first stage payload, by reversing it in Ghidra.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3ce8b3f6406a\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": [
      "ransomware",
      "malware",
      "malware-analysis",
      "cybersecurity",
      "reverse-engineering"
    ]
  }
]
